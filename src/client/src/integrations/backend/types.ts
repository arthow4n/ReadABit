/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.5.0 (NJsonSchema v10.3.7.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export module Backend {

export interface IClient {
    articleCollections_List(request: { filter_LanguageCode: string | null, filter_OwnedByUserId?: string | null | undefined, filter_Name?: string | null | undefined, page_Index?: number | undefined, page_Size?: number | null | undefined, sortBy?: SortBy | undefined }): Promise<PaginatedOfArticleCollectionListItemViewModel>;
    articleCollections_Create(request: { request: ArticleCollectionCreate }): Promise<ArticleCollectionViewModel>;
    articleCollections_Get(request: { id: string }): Promise<ArticleCollectionViewModel>;
    articleCollections_Update(request: { id: string, request: ArticleCollectionUpdate }): Promise<void>;
    articleCollections_Delete(request: { id: string }): Promise<void>;
    articles_List(request: { articleCollectionId?: string | null | undefined, page_Index?: number | undefined, page_Size?: number | null | undefined, sortBy?: SortBy | undefined }): Promise<PaginatedOfArticleListItemViewModel>;
    articles_Create(request: { request: ArticleCreate }): Promise<Article>;
    articles_Get(request: { id: string }): Promise<ArticleViewModel>;
    articles_Update(request: { id: string, request: ArticleUpdate }): Promise<void>;
    articles_Delete(request: { id: string }): Promise<void>;
    articles_UpsertReadingProgress(request: { id: string, request: ArticleReadingProgressUpsert }): Promise<void>;
    cultureInfo_ListAllSupportedTimeZones(request: {  }): Promise<TimeZoneInfoViewModel[]>;
    userPreferences_Get(request: {  }): Promise<UserPreferenceData>;
    userPreferences_Upsert(request: { request: UserPreferenceUpsert }): Promise<void>;
    wordDefinitions_List(request: { filter_Word_LanguageCode: string | null, filter_Word_Expression: string | null, page_Index?: number | undefined, page_Size?: number | null | undefined }): Promise<PaginatedOfWordDefinition>;
    wordDefinitions_Create(request: { request: WordDefinitionCreate }): Promise<WordDefinition>;
    wordDefinitions_ListPublicSuggestions(request: { filter_Word_LanguageCode: string | null, filter_Word_Expression: string | null, filter_PreferredLanguageCode?: string | null | undefined, page_Index?: number | undefined, page_Size?: number | null | undefined }): Promise<PaginatedOfWordDefinitionListPublicSuggestionViewModel>;
    wordDefinitions_Get(request: { id: string }): Promise<WordDefinition>;
    wordDefinitions_Update(request: { id: string, request: WordDefinitionUpdate }): Promise<void>;
    wordDefinitions_Delete(request: { id: string }): Promise<void>;
    wordFamiliarities_List(request: {  }): Promise<WordFamiliarityListViewModel>;
    wordFamiliarities_UpsertBatch(request: { request: WordFamiliarityUpsertBatch }): Promise<WordFamiliarityUpsertBatchResultViewModal>;
    wordFamiliarities_DailyGoalCheck(request: {  }): Promise<WordFamiliarityDailyGoalCheckViewModel>;
}

export class Client implements IClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    articleCollections_List(request: { filter_LanguageCode: string | null, filter_OwnedByUserId?: string | null | undefined, filter_Name?: string | null | undefined, page_Index?: number | undefined, page_Size?: number | null | undefined, sortBy?: SortBy | undefined }, cancelToken?: CancelToken | undefined ): Promise<PaginatedOfArticleCollectionListItemViewModel> {
        let url_ = this.baseUrl + "/api/v1/ArticleCollections?";
        if (request.filter_LanguageCode === undefined)
            throw new Error("The parameter 'request.filter_LanguageCode' must be defined.");
        else if(request.filter_LanguageCode !== null)
            url_ += "Filter.LanguageCode=" + encodeURIComponent("" + request.filter_LanguageCode) + "&";
        if (request.filter_OwnedByUserId !== undefined && request.filter_OwnedByUserId !== null)
            url_ += "Filter.OwnedByUserId=" + encodeURIComponent("" + request.filter_OwnedByUserId) + "&";
        if (request.filter_Name !== undefined && request.filter_Name !== null)
            url_ += "Filter.Name=" + encodeURIComponent("" + request.filter_Name) + "&";
        if (request.page_Index === null)
            throw new Error("The parameter 'request.page_Index' cannot be null.");
        else if (request.page_Index !== undefined)
            url_ += "Page.Index=" + encodeURIComponent("" + request.page_Index) + "&";
        if (request.page_Size !== undefined && request.page_Size !== null)
            url_ += "Page.Size=" + encodeURIComponent("" + request.page_Size) + "&";
        if (request.sortBy === null)
            throw new Error("The parameter 'request.sortBy' cannot be null.");
        else if (request.sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + request.sortBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArticleCollections_List(_response);
        });
    }

    protected processArticleCollections_List(response: AxiosResponse): Promise<PaginatedOfArticleCollectionListItemViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return result200;
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    articleCollections_Create(request: { request: ArticleCollectionCreate }, cancelToken?: CancelToken | undefined ): Promise<ArticleCollectionViewModel> {
        let url_ = this.baseUrl + "/api/v1/ArticleCollections";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request.request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArticleCollections_Create(_response);
        });
    }

    protected processArticleCollections_Create(response: AxiosResponse): Promise<ArticleCollectionViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return result201;
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    articleCollections_Get(request: { id: string }, cancelToken?: CancelToken | undefined ): Promise<ArticleCollectionViewModel> {
        let url_ = this.baseUrl + "/api/v1/ArticleCollections/{id}";
        if (request.id === undefined || request.id === null)
            throw new Error("The parameter 'request.id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + request.id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArticleCollections_Get(_response);
        });
    }

    protected processArticleCollections_Get(response: AxiosResponse): Promise<ArticleCollectionViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return result200;
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    articleCollections_Update(request: { id: string, request: ArticleCollectionUpdate }, cancelToken?: CancelToken | undefined ): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/ArticleCollections/{id}";
        if (request.id === undefined || request.id === null)
            throw new Error("The parameter 'request.id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + request.id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request.request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArticleCollections_Update(_response);
        });
    }

    protected processArticleCollections_Update(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    articleCollections_Delete(request: { id: string }, cancelToken?: CancelToken | undefined ): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/ArticleCollections/{id}";
        if (request.id === undefined || request.id === null)
            throw new Error("The parameter 'request.id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + request.id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArticleCollections_Delete(_response);
        });
    }

    protected processArticleCollections_Delete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    articles_List(request: { articleCollectionId?: string | null | undefined, page_Index?: number | undefined, page_Size?: number | null | undefined, sortBy?: SortBy | undefined }, cancelToken?: CancelToken | undefined ): Promise<PaginatedOfArticleListItemViewModel> {
        let url_ = this.baseUrl + "/api/v1/Articles?";
        if (request.articleCollectionId !== undefined && request.articleCollectionId !== null)
            url_ += "ArticleCollectionId=" + encodeURIComponent("" + request.articleCollectionId) + "&";
        if (request.page_Index === null)
            throw new Error("The parameter 'request.page_Index' cannot be null.");
        else if (request.page_Index !== undefined)
            url_ += "Page.Index=" + encodeURIComponent("" + request.page_Index) + "&";
        if (request.page_Size !== undefined && request.page_Size !== null)
            url_ += "Page.Size=" + encodeURIComponent("" + request.page_Size) + "&";
        if (request.sortBy === null)
            throw new Error("The parameter 'request.sortBy' cannot be null.");
        else if (request.sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + request.sortBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArticles_List(_response);
        });
    }

    protected processArticles_List(response: AxiosResponse): Promise<PaginatedOfArticleListItemViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return result200;
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    articles_Create(request: { request: ArticleCreate }, cancelToken?: CancelToken | undefined ): Promise<Article> {
        let url_ = this.baseUrl + "/api/v1/Articles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request.request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArticles_Create(_response);
        });
    }

    protected processArticles_Create(response: AxiosResponse): Promise<Article> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return result201;
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    articles_Get(request: { id: string }, cancelToken?: CancelToken | undefined ): Promise<ArticleViewModel> {
        let url_ = this.baseUrl + "/api/v1/Articles/{id}";
        if (request.id === undefined || request.id === null)
            throw new Error("The parameter 'request.id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + request.id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArticles_Get(_response);
        });
    }

    protected processArticles_Get(response: AxiosResponse): Promise<ArticleViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return result200;
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    articles_Update(request: { id: string, request: ArticleUpdate }, cancelToken?: CancelToken | undefined ): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/Articles/{id}";
        if (request.id === undefined || request.id === null)
            throw new Error("The parameter 'request.id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + request.id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request.request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArticles_Update(_response);
        });
    }

    protected processArticles_Update(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    articles_Delete(request: { id: string }, cancelToken?: CancelToken | undefined ): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/Articles/{id}";
        if (request.id === undefined || request.id === null)
            throw new Error("The parameter 'request.id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + request.id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArticles_Delete(_response);
        });
    }

    protected processArticles_Delete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    articles_UpsertReadingProgress(request: { id: string, request: ArticleReadingProgressUpsert }, cancelToken?: CancelToken | undefined ): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/Articles/{id}";
        if (request.id === undefined || request.id === null)
            throw new Error("The parameter 'request.id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + request.id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request.request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArticles_UpsertReadingProgress(_response);
        });
    }

    protected processArticles_UpsertReadingProgress(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    cultureInfo_ListAllSupportedTimeZones(request: {  } = { }, cancelToken?: CancelToken | undefined ): Promise<TimeZoneInfoViewModel[]> {
        let url_ = this.baseUrl + "/SupportedTimeZones";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCultureInfo_ListAllSupportedTimeZones(_response);
        });
    }

    protected processCultureInfo_ListAllSupportedTimeZones(response: AxiosResponse): Promise<TimeZoneInfoViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return result200;
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    userPreferences_Get(request: {  } = { }, cancelToken?: CancelToken | undefined ): Promise<UserPreferenceData> {
        let url_ = this.baseUrl + "/api/v1/UserPreferences";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserPreferences_Get(_response);
        });
    }

    protected processUserPreferences_Get(response: AxiosResponse): Promise<UserPreferenceData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return result200;
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    userPreferences_Upsert(request: { request: UserPreferenceUpsert }, cancelToken?: CancelToken | undefined ): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/UserPreferences";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request.request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserPreferences_Upsert(_response);
        });
    }

    protected processUserPreferences_Upsert(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    wordDefinitions_List(request: { filter_Word_LanguageCode: string | null, filter_Word_Expression: string | null, page_Index?: number | undefined, page_Size?: number | null | undefined }, cancelToken?: CancelToken | undefined ): Promise<PaginatedOfWordDefinition> {
        let url_ = this.baseUrl + "/api/v1/WordDefinitions?";
        if (request.filter_Word_LanguageCode === undefined)
            throw new Error("The parameter 'request.filter_Word_LanguageCode' must be defined.");
        else if(request.filter_Word_LanguageCode !== null)
            url_ += "Filter.Word.LanguageCode=" + encodeURIComponent("" + request.filter_Word_LanguageCode) + "&";
        if (request.filter_Word_Expression === undefined)
            throw new Error("The parameter 'request.filter_Word_Expression' must be defined.");
        else if(request.filter_Word_Expression !== null)
            url_ += "Filter.Word.Expression=" + encodeURIComponent("" + request.filter_Word_Expression) + "&";
        if (request.page_Index === null)
            throw new Error("The parameter 'request.page_Index' cannot be null.");
        else if (request.page_Index !== undefined)
            url_ += "Page.Index=" + encodeURIComponent("" + request.page_Index) + "&";
        if (request.page_Size !== undefined && request.page_Size !== null)
            url_ += "Page.Size=" + encodeURIComponent("" + request.page_Size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWordDefinitions_List(_response);
        });
    }

    protected processWordDefinitions_List(response: AxiosResponse): Promise<PaginatedOfWordDefinition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return result200;
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    wordDefinitions_Create(request: { request: WordDefinitionCreate }, cancelToken?: CancelToken | undefined ): Promise<WordDefinition> {
        let url_ = this.baseUrl + "/api/v1/WordDefinitions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request.request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWordDefinitions_Create(_response);
        });
    }

    protected processWordDefinitions_Create(response: AxiosResponse): Promise<WordDefinition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return result201;
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    wordDefinitions_ListPublicSuggestions(request: { filter_Word_LanguageCode: string | null, filter_Word_Expression: string | null, filter_PreferredLanguageCode?: string | null | undefined, page_Index?: number | undefined, page_Size?: number | null | undefined }, cancelToken?: CancelToken | undefined ): Promise<PaginatedOfWordDefinitionListPublicSuggestionViewModel> {
        let url_ = this.baseUrl + "/Suggestions?";
        if (request.filter_Word_LanguageCode === undefined)
            throw new Error("The parameter 'request.filter_Word_LanguageCode' must be defined.");
        else if(request.filter_Word_LanguageCode !== null)
            url_ += "Filter.Word.LanguageCode=" + encodeURIComponent("" + request.filter_Word_LanguageCode) + "&";
        if (request.filter_Word_Expression === undefined)
            throw new Error("The parameter 'request.filter_Word_Expression' must be defined.");
        else if(request.filter_Word_Expression !== null)
            url_ += "Filter.Word.Expression=" + encodeURIComponent("" + request.filter_Word_Expression) + "&";
        if (request.filter_PreferredLanguageCode !== undefined && request.filter_PreferredLanguageCode !== null)
            url_ += "Filter.PreferredLanguageCode=" + encodeURIComponent("" + request.filter_PreferredLanguageCode) + "&";
        if (request.page_Index === null)
            throw new Error("The parameter 'request.page_Index' cannot be null.");
        else if (request.page_Index !== undefined)
            url_ += "Page.Index=" + encodeURIComponent("" + request.page_Index) + "&";
        if (request.page_Size !== undefined && request.page_Size !== null)
            url_ += "Page.Size=" + encodeURIComponent("" + request.page_Size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWordDefinitions_ListPublicSuggestions(_response);
        });
    }

    protected processWordDefinitions_ListPublicSuggestions(response: AxiosResponse): Promise<PaginatedOfWordDefinitionListPublicSuggestionViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return result200;
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    wordDefinitions_Get(request: { id: string }, cancelToken?: CancelToken | undefined ): Promise<WordDefinition> {
        let url_ = this.baseUrl + "/api/v1/WordDefinitions/{id}";
        if (request.id === undefined || request.id === null)
            throw new Error("The parameter 'request.id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + request.id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWordDefinitions_Get(_response);
        });
    }

    protected processWordDefinitions_Get(response: AxiosResponse): Promise<WordDefinition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return result200;
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    wordDefinitions_Update(request: { id: string, request: WordDefinitionUpdate }, cancelToken?: CancelToken | undefined ): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/WordDefinitions/{id}";
        if (request.id === undefined || request.id === null)
            throw new Error("The parameter 'request.id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + request.id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request.request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWordDefinitions_Update(_response);
        });
    }

    protected processWordDefinitions_Update(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    wordDefinitions_Delete(request: { id: string }, cancelToken?: CancelToken | undefined ): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/WordDefinitions/{id}";
        if (request.id === undefined || request.id === null)
            throw new Error("The parameter 'request.id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + request.id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWordDefinitions_Delete(_response);
        });
    }

    protected processWordDefinitions_Delete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    wordFamiliarities_List(request: {  } = { }, cancelToken?: CancelToken | undefined ): Promise<WordFamiliarityListViewModel> {
        let url_ = this.baseUrl + "/api/v1/WordFamiliarities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWordFamiliarities_List(_response);
        });
    }

    protected processWordFamiliarities_List(response: AxiosResponse): Promise<WordFamiliarityListViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return result200;
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    wordFamiliarities_UpsertBatch(request: { request: WordFamiliarityUpsertBatch }, cancelToken?: CancelToken | undefined ): Promise<WordFamiliarityUpsertBatchResultViewModal> {
        let url_ = this.baseUrl + "/api/v1/WordFamiliarities/UpsertBatch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request.request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWordFamiliarities_UpsertBatch(_response);
        });
    }

    protected processWordFamiliarities_UpsertBatch(response: AxiosResponse): Promise<WordFamiliarityUpsertBatchResultViewModal> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return result200;
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }

    wordFamiliarities_DailyGoalCheck(request: {  } = { }, cancelToken?: CancelToken | undefined ): Promise<WordFamiliarityDailyGoalCheckViewModel> {
        let url_ = this.baseUrl + "/DailyGoalCheck";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWordFamiliarities_DailyGoalCheck(_response);
        });
    }

    protected processWordFamiliarities_DailyGoalCheck(response: AxiosResponse): Promise<WordFamiliarityDailyGoalCheckViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return result200;
        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = tryJsonParse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }
}

export interface PaginatedOfArticleCollectionListItemViewModel {
    page: PageInfo;
    items: ArticleCollectionListItemViewModel[];
}

export interface PageInfo {
    current: PageFilterFilled;
    next?: PageFilterFilled | null;
    previous?: PageFilterFilled | null;
    totalPages: number;
    totalCount: number;
}

export interface PageFilter {
    index: number;
    size?: number | null;
}

export interface PageFilterFilled extends PageFilter {
    size: number;
}

export interface ArticleCollectionListItemViewModel {
    id: string;
    userId: string;
    name: string;
    languageCode: string;
    public: boolean;
    createdAt: Date;
    updatedAt: Date;
}

export interface ProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;
    extensions?: { [key: string]: any; } | null;
}

export enum SortBy {
    LastUpdated = "LastUpdated",
    LastCreated = "LastCreated",
    CreatedAt = "CreatedAt",
    LastAccessed = "LastAccessed",
    OrderInCollection = "OrderInCollection",
}

export interface ArticleCollectionViewModel {
    id: string;
    userId: string;
    name: string;
    languageCode: string;
    public: boolean;
    createdAt: Date;
    updatedAt: Date;
}

export interface ArticleCollectionCreate {
    name: string;
    languageCode: string;
    public: boolean;
}

export interface ArticleCollectionUpdate {
    name?: string | null;
    languageCode?: string | null;
    public?: boolean | null;
}

export interface PaginatedOfArticleListItemViewModel {
    page: PageInfo;
    items: ArticleListItemViewModel[];
}

export interface ArticleListItemViewModel {
    id: string;
    articleCollectionId: string;
    name: string;
    readRadio: number;
}

export interface ArticleViewModel {
    id: string;
    articleCollectionId: string;
    name: string;
    languageCode: string;
    conlluDocument: ConlluDocumentViewModel;
    createdAt: Date;
    updatedAt: Date;
    readingProgress: ArticleReadingProgressViewModel;
}

export interface ConlluDocumentViewModel {
    id: string;
    paragraphs: ConlluParagraphViewModel[];
}

export interface ConlluParagraphViewModel {
    id: string;
    sentences: ConlluSentenceViewModel[];
}

export interface ConlluSentenceViewModel {
    id: string;
    text: string;
    tokens: ConlluTokenViewModel[];
}

export interface ConlluTokenViewModel {
    id: string;
    form: string;
    lemma: string;
    upos: string;
    xpos: string;
    feats: string;
    head: string;
    deprel: string;
    deps: string;
    misc: string;
    languageCode: string;
    normalisedToken: ConlluNormalisedTokenViewModel;
}

export interface ConlluNormalisedTokenViewModel {
    form: string;
    lemma: string;
    languageCode: string;
}

export interface ArticleReadingProgressViewModel {
    conlluTokenPointer: TokenPointer;
    readRatio: number;
    createdAt: Date;
    updatedAt: Date;
}

export interface TokenPointer {
    documentIndex: number;
    paragraphIndex: number;
    sentenceIndex: number;
    tokenIndex: number;
}

export interface Article {
    id: string;
    articleCollectionId: string;
    articleCollection?: ArticleCollection | null;
    order: number;
    name: string;
    text: string;
    conlluDocument: Document;
    createdAt: Date;
    updatedAt: Date;
    articleReadingProgress?: ArticleReadingProgress[] | null;
}

export interface ArticleCollection {
    id: string;
    userId: string;
    user?: ApplicationUser | null;
    name: string;
    languageCode: string;
    articles?: Article[] | null;
    public: boolean;
    createdAt: Date;
    updatedAt: Date;
}

export interface IdentityUserOfGuid {
    id: string;
    userName?: string | null;
    normalizedUserName?: string | null;
    email?: string | null;
    normalizedEmail?: string | null;
    emailConfirmed: boolean;
    passwordHash?: string | null;
    securityStamp?: string | null;
    concurrencyStamp?: string | null;
    phoneNumber?: string | null;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd?: Date | null;
    lockoutEnabled: boolean;
    accessFailedCount: number;
}

export interface ApplicationUser extends IdentityUserOfGuid {
}

export interface Document {
    id: string;
    paragraphs: Paragraph[];
}

export interface Paragraph {
    id: string;
    sentences: Sentence[];
}

export interface Sentence {
    id: string;
    text: string;
    tokens: Token[];
}

export interface Token {
    id: string;
    form: string;
    lemma: string;
    upos: string;
    xpos: string;
    feats: string;
    head: string;
    deprel: string;
    deps: string;
    misc: string;
}

export interface ArticleReadingProgress {
    id: string;
    userId: string;
    user?: ApplicationUser | null;
    articleId: string;
    article?: Article | null;
    conlluTokenPointer: TokenPointer;
    readRatio: number;
    createdAt: Date;
    updatedAt: Date;
}

export interface ArticleCreate {
    articleCollectionId: string;
    name: string;
    text: string;
}

export interface ArticleUpdate {
    name?: string | null;
    text?: string | null;
}

export interface ArticleReadingProgressUpsert {
    conlluTokenPointer: TokenPointer;
    readRatio: number;
}

export interface TimeZoneInfoViewModel {
    id: string;
    displayName: string;
}

export interface UserPreferenceData {
    dailyGoalResetTimeTimeZone?: string | null;
    dailyGoalResetTimePartial?: string | null;
    dailyGoalNewlyCreatedWordFamiliarityCount: number;
}

export interface UserPreferenceUpsert {
    data: UserPreferenceData;
}

export interface PaginatedOfWordDefinition {
    page: PageInfo;
    items: WordDefinition[];
}

export interface WordDefinition {
    id: string;
    wordId: string;
    word?: Word | null;
    userId: string;
    user?: ApplicationUser | null;
    public: boolean;
    languageCode: string;
    meaning: string;
    createdAt: Date;
    updatedAt: Date;
}

export interface Word {
    id: string;
    languageCode: string;
    expression: string;
}

export interface PaginatedOfWordDefinitionListPublicSuggestionViewModel {
    page: PageInfo;
    items: WordDefinitionListPublicSuggestionViewModel[];
}

export interface WordDefinitionListPublicSuggestionViewModel {
    languageCode: string;
    meaning: string;
    count: number;
}

export interface WordDefinitionCreate {
    word: WordSelector;
    public: boolean;
    languageCode: string;
    meaning: string;
}

export interface WordSelector {
    languageCode: string;
    expression: string;
}

export interface WordDefinitionUpdate {
    public?: boolean | null;
    languageCode?: string | null;
    meaning?: string | null;
}

export interface WordFamiliarityListViewModel {
    groupedWordFamiliarities: { [key: string]: { [key: string]: WordFamiliarityListItemViewModel; }; };
}

export interface WordFamiliarityListItemViewModel {
    word: WordSelector;
    level: number;
}

export interface WordFamiliarityUpsertBatchResultViewModal {
    dailyGoalStatus: WordFamiliarityDailyGoalCheckViewModel;
}

export interface WordFamiliarityDailyGoalCheckViewModel {
    newlyCreated: number;
    newlyCreatedGoal: number;
    newlyCreatedReached: boolean;
}

export interface WordFamiliarityUpsertBatch {
    level: number;
    words: WordSelector[];
}

export class BackendCallException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.name = 'BackendCallException';
        this.message = `${message}: ${status}, ${result}, ${response}`;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isBackendCallException = true;

    static isBackendCallException(obj: any): obj is BackendCallException {
        return obj.isBackendCallException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    console.error(`Backend.Client.throwException: ${status}, ${result}, ${response}`);
    throw new BackendCallException(message, status, response, headers, result);
}

function tryJsonParse(json: string): any {
    try {
        return JSON.parse(json);
    } catch { }
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

}